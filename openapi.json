{
  "swagger": "2.0",
  "info": {
    "title": "Flexa Connect - Payment API",
    "description": "The Payment API is used by merchants, processors, gateways, etc. to create and manage charges.\n\n## gRPC and RESTful JSON (OpenAPI V2) APIs\nThe service supports both gRPC and RESTful JSON APIs. The gRPC API is strongly preferred.\n\nInternally, the RESTful JSON API is implemented as a wrapper around the gRPC API. As a result, the latter is the \"native\" API that has fewer moving pieces, lower latency, and may expose more functionality. The former is provided only for compatibility in cases where gRPC cannot be used due to technical limitations.\n\nBoth APIs listen on port 443 on the same domain (host). Clients wishing to access the RESTful JSON API must set the \"accept\" header to have the value \"application/vnd.flexa.connect.v1+json\", otherwise the request will be interpreted as gRPC.\n\n## Backwards Compatibility\nThe service abides by Semantic Versioning 2.0.0. Non-breaking, backwards-compatibility will be maintained for the life of the major version.\n\nWithin a major version, any kind of backwards-compatible, non-breaking changes can be made, including:\n  * New fields may be added to types within responses (including new\n    kinds of events within streams)\n  * New, optional fields may be added to types within requests\n  * New methods/endpoints may be added\n  * New error codes may be returned\n\n\nThis implies that clients must ignore unknown fields within responses (including whole new event types in streams) and may not rely on knowing an exhaustive list of status codes.\n\nSee: https://semver.org/\n\n## Encryption (TLS/SSL)\nAll connections to the service must be encrypted using TLS (SSL). The server will use a certificate signed by a certificate authority that is trusted by most system certificate pools (eg the ones included in the \"ca-certificates\" package on Debian/Ubuntu/Alpine Linux). Some gRPC clients (eg grpc-go) may require explicitly trusting the system cert pool on initialization.\n\nClients must not provide their own client TLS key or certificate (ie mTLS must not be used). Clients use tokens to authenticate, see Authentication section below.\n\ngRPC uses HTTP/2. TLS connections use Application-Layer Protocol Negotiation (APLN) to upgrade a connection to HTTP/2. Some client libraries (eg Java before version 9) require a library/setting to support/enable APLN.\n\n## Authentication\nAuthentication tokens are provided out of band. The token is used to identify the client application and must be included verbatim in all requests. It must not be interpreted in any way and should be treated as an opaque string.\n\nAll requests must set the \"authorization\" metadata key (gRPC) or header (RESTful JSON) to have the value \"Bearer opaqueTokenString\". Where \"opaqueTokenString\" is the previously-provided token.\n\n## Parallelism (multiple clients)\nEach of this service's methods act either atomically or idempotently. Multiple connections (from one or more clients) can safely be used to make simultaneous requests.\n\nSee Idempotency section below.\n\n## Pagination\nAll methods that return lists support pagination. Their requests contain Page Token and Page Size fields and their responses contain a Next Page Token field.\nSee: https://cloud.google.com/apis/design/design_patterns#list_pagination\n\n## Idempotency\nSometimes requests fail due to network connectivity issues. If the request was changing state (eg creating a new object), the client won't know whether the request succeeded. If it had, then sending another request could result in duplicated effects. If it hadn't, then not sending another request would result in missing effects.\n\nTo prevent this, requests that change state in a way that's not inherently idempotent (eg ones that create new objects) must set the \"idempotency-key\" metadata key (gRPC) or header (RESTful JSON) to a new, unique nonce.\n\nIf there is a possible connection error, then the request should be retried again with the same parameters and Idempotency Key. This will ensure that the result (success or failure) of the original attempt is returned and prevents erroneous duplication if the request was successfully processed but that result couldn't be returned.\n\nThe results associated with a particular Idempotency Key are retained for at least 24 hours. If an Idempotency Key is reused after that time it may result in a new request being processed.\n\nIdempotency Keys must be strings containing at most 1024 bytes. Usually it's best to generate a new V4 UUID.\n\nRequests will return status code Invalid Argument if an Idempotency Key is either omitted from a not-inherently-idempotent request or reused with different parameters.\n\nRetries should use an exponential-backoff algorithm and incorporate some jitter to avoid overwhelming the server with a flood of synchronized retries.\n\nIn addition to TCP disconnections, the following status codes should generally be retried:\n  * Unavailable\n  * Canceled\n  * Deadline Exceeded\n  * Unknown\n\n\n## Keepalive\nLong-running, idle TCP connections can silently fail for various reasons (eg a L4 proxy may silently drop state for \"idle\" connections). Requests that block for arbitrary amounts of time waiting for updates (like streams) should enable gRPC's Keepalive functionality (eg grpc-go clients should set `keepalive.ClientParameters.Time = 1 * time.Minute`).\n\nSee: https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md\nSee: https://github.com/grpc/grpc/blob/master/doc/keepalive.md\n\n## Streams\nStreams continually and indefinitely return instances of the same response type. Unless there is an error, the server never closes stream/connection, therefore the status code OK is never returned.\n\nLong-running, idle TCP connections can silently fail for various reasons (eg a L4 proxy may silently drop state for \"idle\" connections). The server will attempt to prevent this by periodically sending Heartbeats on streams that haven't sent a response instance in a while. The client should cancel/close the stream (and re-call the method if needed) if it's been \"too long\" without a response instance of any kind (Heartbeat or otherwise). Currently the server sends a Heartbeat on a stream once it's been idle for 1 minute so a client should cancel/close a stream that's gone 90-120 seconds without any response instance. **Clients that don't implement a timeout may end up listening forever to a silently-broken connection.**  See Keepalive section above.\n\nNew event types may be added to the response at any time, see Backwards Compatibility section above.\n\nThe RESTful JSON API uses HTTP's Chunked Transfer-Encoding, returning one response instance per Chunk. Clients must ensure that they can stream individual Chunks, otherwise they will block, waiting forever for the HTTP response to be \"complete\" (which will never happen).\n\nSee: https://en.wikipedia.org/wiki/Chunked_transfer_encoding\n\n## Client IDs\nClient IDs are usually optional and may be omitted from most requests without any change in functionality.\n\nSome clients have their own audit IDs, transaction IDs, or other kind of identifiers/state that they'd like to associate with various requests. If so, they can be supplied in the Client ID field within the appropriate requests.\n\nThe service does not assign any semantic meaning to the contents of the Client ID. When present, the server just validates that it's a string containing no more than 1024 bytes and ensures that it's unique.\n\nIf it would be useful to have any any other functionality based off of the Client ID, please let us know.\n\n## Debugging\nAll requests may set the \"x-client-trace-id\" metadata key (gRPC) or header (RESTful JSON) to a unique string containing at most 1024 bytes. Usually it's best to generate a new V4 UUID.\n\nThese Client Trace IDs will be logged in server-side messages and trace and are immensely helpful when trying to debug issues. Clients should also log the Client Trace ID of any abnormal/delayed/failing request so they can be correlated as needed.\n\n## Error Codes\nThis service returns the appropriate, standardized gRPC status codes for all error conditions.\n\nAll methods can return at least the following errors (and will individually document any other codes they may return):\n  * OK: success\n  * Unauthenticated: see Authentication section above\n  * Permission Denied: provided token not authorized to perform\n    requested action\n  * Invalid Argument: see returned error message for details\n  * Unavailable: transient error, please retry with a backoff and\n    report if it persists (include any returned error message)\n  * Unimplemented: functionality is not yet available, please let us\n    know if a particular feature would be useful so we prioritize its\n    implementation\n  * Internal: server-side issue, an automatic alert will have been\n    raised, but please report if it persists (include any returned\n    error message)\n\n\nClient implementations may also generate their own status codes including:\n  * Canceled\n  * Deadline Exceeded: timeouts can occur due to network conditions\n    (see Keepalive section above) or server issues, please report\n    suspicions of the latter\n  * Unknown: should not ever be returned from ther server; if it\n    is, an automatic alert will have been raised, but please report\n    if it persists (include any returned error message)\n\n\nSee: https://github.com/grpc/grpc/blob/master/doc/statuscodes.md\n",
    "version": "v1",
    "contact": {
      "name": "Flexa",
      "url": "https://flexa.network",
      "email": "connect@flexa.network"
    }
  },
  "host": "api.connect.flexa.network",
  "schemes": [
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/vnd.flexa.connect.v1+json"
  ],
  "paths": {
    "/payment/assets": {
      "get": {
        "summary": "Get Asset By Currency: Returns the assetID associated with an ISO 4217 currency code.",
        "description": "The assetId is an internal Asset ID used by Flexa for a given ISO 4217 currency code.\n\nReturns status code \"Not Found\" for an unknown Currency Code, otherwise this API returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_GetAssetByCurrency",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetAssetByCurrencyResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "currencyCode",
            "description": "[ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code. Example: `USD`",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/chargecodes": {
      "post": {
        "summary": "Create Charge Code: creates a Charge (request for payment) and a Charge Code to display.",
        "description": "Should be called when the Flexa payment method is selected and the point-of-sale is capable of displaying a Charge Code (2d barcode) for the payer's device to scan.\n\nThe point-of-sale should display the resulting Charge Code then Watch Charge should be called to follow and respond to the resulting Charge's status updates.\n\nDuplicated actions must be prevented, see Idempotency section above.\n\nReturns status code \"Not Found\" for an unknown Merchant ID, returns status code \"Already Exists\" if the Client Charge ID is provided and has already been charged, otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_CreateChargeCode",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateChargeCodeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateChargeCodeRequest"
            }
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/charges": {
      "get": {
        "summary": "Get Charge: fetches Charge status.",
        "description": "This API can be used as a polling alternative to the stream-based watch/watchall APIs.\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.",
        "operationId": "PaymentService_GetCharge2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1Charge"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.clientChargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.merchantId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "updates"
        ]
      },
      "delete": {
        "summary": "Delete Charge: deletes (cancels) a non-Completed Charge.",
        "description": "May be called before the Charge is Completed.\n\nIf this call returns successfully, then the authorized amount will have been released back to the payer and the Charge may no longer be Completed.\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.\n\nMay be retried idempotently.\n\nReturns status code \"Not Found\" for an unknown Charge ID, returns status code \"Failed Precondition\" if the Charge is not currently either Created, Authorized, or Deleted (e.g. has already been Completed), otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_DeleteCharge2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteChargeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.clientChargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.merchantId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "PaymentService"
        ]
      },
      "post": {
        "summary": "Create Charge: creates a Charge (request for payment).",
        "description": "Create charge should be called when the point-of-sale scans a Flexcode from the payer's device. Watch Charge or Get Charge should be called to follow and respond to the resulting Charge's status updates.\n\nDuplicated actions must be prevented, see the Idempotency section above.\n\nReturns status code \"Not Found\" for an unknown Merchant ID or Flexcode Data, returns status code \"Already Exists\" if the Flexcode Data has already been charged or the Client Charge ID is provided and has already been charged, otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_CreateCharge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateChargeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateChargeRequest"
            }
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/charges/complete": {
      "put": {
        "summary": "Complete Charge: completes (captures) an authorized Charge.",
        "description": "Should be called once the Charge is Authorized.\n\nIf this call returns successfully, then the authorized amount will have been retrieved from the payer and the Charge may no longer be Deleted (though may be refunded).\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.\n\nMay be retried idempotently.\n\nReturns status code \"Not Found\" for an unknown Charge ID, returns status code \"Failed Precondition\" if the Charge is not currently either Authorized or Completed (e.g. has already been Deleted), otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_CompleteCharge2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CompleteChargeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/charges/watch": {
      "get": {
        "summary": "Watch Charge: streams updates to a single Charge's status.",
        "description": "The Charge's current status is streamed immediately and subsequent status changes will be streamed as they occur.\n\nNo states prior to the current one will be streamed/replayed.\n\nComplete Charge should be called once the Charge is Authorized.\nDelete Charge may optionally be called before the Charge is Completed.\nCreate Refund may optionally be called after the Charge is Completed.\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.\n\nNever returns status code \"OK\" (see Streams section above), returns status code \"Not Found\" for an unknown Charge ID, otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_WatchCharge2",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1WatchChargeResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1WatchChargeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.clientChargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.merchantId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "updates"
        ]
      }
    },
    "/payment/charges/watchall": {
      "get": {
        "summary": "Watch All Charges: streams updates to multiple Charges' statuses.",
        "description": "Changes to the Charges' statuses are streamed as they occur.\n\nComplete Charge should be called once a Charge is Authorized.\nDelete Charge may optionally be called before a Charge is Completed.\nCreate Refund may optionally be called after a Charge is Completed.\n\nNever returns status code \"OK\" (see Streams section above), returns status code \"Not Found\" for an unknown Merchant ID, otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_WatchCharges",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1WatchChargesResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1WatchChargesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "eventToken",
            "description": "Optional value previously returned in an Event's next_event_token field.\nIf omitted, the stream will start from the beginning, returning all events.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "merchantId",
            "description": "Events for this merchant's Charges will be streamed in the response.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/charges/{chargeId}": {
      "get": {
        "summary": "Get Charge: fetches Charge status.",
        "description": "This API can be used as a polling alternative to the stream-based watch/watchall APIs.\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.",
        "operationId": "PaymentService_GetCharge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1Charge"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.clientChargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.merchantId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "updates"
        ]
      },
      "delete": {
        "summary": "Delete Charge: deletes (cancels) a non-Completed Charge.",
        "description": "May be called before the Charge is Completed.\n\nIf this call returns successfully, then the authorized amount will have been released back to the payer and the Charge may no longer be Completed.\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.\n\nMay be retried idempotently.\n\nReturns status code \"Not Found\" for an unknown Charge ID, returns status code \"Failed Precondition\" if the Charge is not currently either Created, Authorized, or Deleted (e.g. has already been Completed), otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_DeleteCharge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteChargeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.clientChargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.merchantId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/charges/{chargeId}/refunds": {
      "post": {
        "summary": "Create Refund: refunds a Charge.",
        "description": "May be called after the Charge is Completed.\n\nMay be called multiple times to issue partial refunds that sum up to less than or equal the amount initially paid.\n\nIf this call returns successfully, then the requested amount will have been returned to the payer.\n\nDuplicated actions must be prevented, see Idempotency section above.\n\nReturns status code \"Not Found\" for an unknown Charge ID or Merchant ID, returns status code \"Failed Precondition\" if the Charge is not currently Completed or doesn't have enough \"unrefunded\" remaining, returns status code \"Already Exists\" if the Client Refund ID is provided and has already been refunded, otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_CreateRefund",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateRefundResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "description": "Charge to be (at least partially) refunded",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateRefundRequest"
            }
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/charges/{chargeId}:complete": {
      "put": {
        "summary": "Complete Charge: completes (captures) an authorized Charge.",
        "description": "Should be called once the Charge is Authorized.\n\nIf this call returns successfully, then the authorized amount will have been retrieved from the payer and the Charge may no longer be Deleted (though may be refunded).\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.\n\nMay be retried idempotently.\n\nReturns status code \"Not Found\" for an unknown Charge ID, returns status code \"Failed Precondition\" if the Charge is not currently either Authorized or Completed (e.g. has already been Deleted), otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_CompleteCharge",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CompleteChargeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    },
    "/payment/charges/{chargeId}:watch": {
      "get": {
        "summary": "Watch Charge: streams updates to a single Charge's status.",
        "description": "The Charge's current status is streamed immediately and subsequent status changes will be streamed as they occur.\n\nNo states prior to the current one will be streamed/replayed.\n\nComplete Charge should be called once the Charge is Authorized.\nDelete Charge may optionally be called before the Charge is Completed.\nCreate Refund may optionally be called after the Charge is Completed.\n\nIf not using the flexa provided chargeId within the url path, clientChargeIdentifier.clientChargeId and clientChargeIdentifier.merchantId are required as a query parameters.\n\nNever returns status code \"OK\" (see Streams section above), returns status code \"Not Found\" for an unknown Charge ID, otherwise it returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_WatchCharge",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/v1WatchChargeResponse"
                },
                "error": {
                  "$ref": "#/definitions/rpcStatus"
                }
              },
              "title": "Stream result of v1WatchChargeResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "chargeId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.clientChargeId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "clientChargeIdentifier.merchantId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "updates"
        ]
      }
    },
    "/payment/quotes": {
      "get": {
        "summary": "GetQuoteByAssetPair: Returns the current quote for an asset pair.",
        "description": "Returns status code \"Not Found\" if attempting to get an unknown asset pair, otherwise this API returns status codes listed in the Error Codes section above.",
        "operationId": "PaymentService_GetQuoteByAssetPair",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetQuoteByAssetPairResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "assetPair.baseCryptoCode",
            "description": "aka CCY1, or the ticker of `BTC` in \"btc_usd\".",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "assetPair.quoteCurrencyCode",
            "description": "aka CCY2, or the ISO 4217 currency code of `USD` in \"btc_usd\".",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "PaymentService"
        ]
      }
    }
  },
  "definitions": {
    "WatchChargesResponseEvent": {
      "type": "object",
      "properties": {
        "nextEventToken": {
          "type": "string",
          "description": "May be provided to subsequent WatchCharges requests to (re)start the\nstream at the next event (e.g. in the case of disconnection).\nIt is an opaque value and must not be interpreted or modified."
        },
        "status": {
          "$ref": "#/definitions/v1ChargeStatus",
          "title": "Charge's current status"
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "typeUrl": {
          "type": "string"
        },
        "value": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "typeAssetAmount": {
      "type": "object",
      "properties": {
        "assetId": {
          "type": "string",
          "title": "Opaque, Flexa-specific identifier"
        },
        "currencyCode": {
          "type": "string",
          "title": "ISO 4217 currency code, eg: `USD`"
        },
        "amount": {
          "$ref": "#/definitions/typeDecimal",
          "title": "Amount is the value represented in the currency's standard precision"
        }
      },
      "description": "A tuple of a Flexa specific asset identifier and an amount (in decimal format)",
      "title": "AssetAmount"
    },
    "typeAssetPair": {
      "type": "object",
      "properties": {
        "baseCryptoCode": {
          "type": "string",
          "title": "aka CCY1, or the ticker of `BTC` in \"btc_usd\""
        },
        "quoteCurrencyCode": {
          "type": "string",
          "title": "aka CCY2, or the ISO 4217 currency code of `USD` in \"btc_usd\""
        }
      },
      "description": "A tuple of asset identifiers",
      "title": "AssetPair"
    },
    "typeDecimal": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string"
        }
      },
      "description": "Decimal represents a decimal value, and is typically used as part of a\nmonetary representation where precision is required.",
      "title": "Decimal"
    },
    "typeImageData": {
      "type": "object",
      "properties": {
        "mimeType": {
          "type": "string",
          "title": "IANA media type of the included data"
        },
        "data": {
          "type": "string",
          "format": "byte",
          "title": "Formatted according to the MIME type"
        }
      },
      "description": "Image data contains the mime type and bytes of an image",
      "title": "ImageData"
    },
    "v1Charge": {
      "type": "object",
      "properties": {
        "chargeId": {
          "type": "string",
          "title": "The unique identifier for this charge"
        },
        "requestedAmount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "The amount initially requested for the charge"
        },
        "authorizedAmount": {
          "$ref": "#/definitions/typeAssetAmount",
          "description": "The amount, if any, that has been authorized and can be charged.\nIf complete_time is not null, this is the amount of the completed charge."
        },
        "createTime": {
          "type": "string",
          "format": "date-time",
          "title": "The time the charge was created"
        },
        "authorizeTime": {
          "type": "string",
          "format": "date-time",
          "title": "The time the charge was authorized, if authorized"
        },
        "deleteTime": {
          "type": "string",
          "format": "date-time",
          "title": "The time the charge was deleted, if deleted"
        },
        "completeTime": {
          "type": "string",
          "format": "date-time",
          "title": "The time the charge was completed, if completed"
        }
      }
    },
    "v1ChargeCode": {
      "type": "object",
      "properties": {
        "imageData": {
          "$ref": "#/definitions/typeImageData",
          "title": "Image to be displayed by point-of-sale"
        },
        "data": {
          "type": "string",
          "title": "Raw data string used to generate Image (2d barcode)"
        }
      },
      "description": "A Charge Code contains metadata that can be used by a point of sale to display information that a customer can use to complete a payment.",
      "title": "Charge Code"
    },
    "v1ChargeStatus": {
      "type": "object",
      "properties": {
        "chargeId": {
          "type": "string"
        },
        "clientChargeId": {
          "type": "string",
          "title": "Client-generated ID if provided when creating Charge\nSee Client IDs section above"
        },
        "created": {
          "$ref": "#/definitions/v1ChargeStatusCreated"
        },
        "deleted": {
          "$ref": "#/definitions/v1ChargeStatusDeleted"
        },
        "authorized": {
          "$ref": "#/definitions/v1ChargeStatusAuthorized"
        },
        "completed": {
          "$ref": "#/definitions/v1ChargeStatusCompleted"
        }
      }
    },
    "v1ChargeStatusAuthorized": {
      "type": "object",
      "properties": {
        "amount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "Amount actually authorized (may be less than amount requested)"
        }
      },
      "description": "Authorized by payer (may still be deleted by either party)",
      "title": "Authorized"
    },
    "v1ChargeStatusCompleted": {
      "type": "object",
      "properties": {
        "amount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "Amount actually paid (equal to amount authorized)"
        }
      },
      "description": "Paid/Completed",
      "title": "Completed"
    },
    "v1ChargeStatusCreated": {
      "type": "object",
      "description": "Newly created (pending)",
      "title": "Created"
    },
    "v1ChargeStatusDeleted": {
      "type": "object",
      "description": "Canceled by either party",
      "title": "Deleted"
    },
    "v1ClientChargeIdentifier": {
      "type": "object",
      "properties": {
        "clientChargeId": {
          "type": "string"
        },
        "merchantId": {
          "type": "string"
        }
      }
    },
    "v1CompleteChargeResponse": {
      "type": "object",
      "title": "Complete Charge Response"
    },
    "v1CreateChargeCodeRequest": {
      "type": "object",
      "properties": {
        "merchantId": {
          "type": "string",
          "title": "The identifier for the Merchant creating the Charge Code"
        },
        "amount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "Asset (currency) and amount of charge"
        },
        "clientChargeId": {
          "type": "string",
          "title": "Optional client-generated, unique ID\nSee Client IDs section above"
        },
        "clientAccountId": {
          "type": "string",
          "description": "The identifier for the Account benefiting from the Charge Code.\n\nUnless explicitly instructed by the Flexa team, this field should be omitted."
        },
        "quoteId": {
          "type": "string",
          "description": "Quote ID that will be used when exchanging assets.\n\nUnless explicitly instructed by the Flexa team, this field should be omitted.\n\nWhen present:\nThe Quote Asset must match the Amount's Asset\nThe customer will be required to pay in the specified Base Asset\nThe Charge's Expire Time will be no later than the Quote's Expire Time,\nafter which the Charge will be Deleted (no longer payable)."
        }
      },
      "title": "Create Charge Code Request"
    },
    "v1CreateChargeCodeResponse": {
      "type": "object",
      "properties": {
        "chargeId": {
          "type": "string"
        },
        "chargeCode": {
          "$ref": "#/definitions/v1ChargeCode",
          "title": "Code to display on point-of-sale"
        },
        "payCode": {
          "type": "string",
          "title": "Alternate identifier that can be used in absence of camera"
        },
        "destinationString": {
          "type": "string",
          "title": "Optional, alternate destination that can be copied and pasted in absence of camera"
        },
        "expireTime": {
          "type": "string",
          "format": "date-time",
          "title": "Time after which the Charge will be Deleted and no longer payable"
        }
      },
      "title": "Create Charge Code Response"
    },
    "v1CreateChargeRequest": {
      "type": "object",
      "properties": {
        "merchantId": {
          "type": "string",
          "title": "The identifier for the Merchant creating the charge"
        },
        "amount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "Asset (currency) and amount of charge"
        },
        "flexcodeData": {
          "type": "string",
          "title": "Data from scanned flexcode"
        },
        "clientChargeId": {
          "type": "string",
          "title": "Optional client-generated, unique ID\nSee Client IDs section above"
        }
      },
      "title": "Create Charge Request"
    },
    "v1CreateChargeResponse": {
      "type": "object",
      "properties": {
        "chargeId": {
          "type": "string"
        }
      },
      "title": "Create Charge Response"
    },
    "v1CreateRefundRequest": {
      "type": "object",
      "properties": {
        "chargeId": {
          "type": "string",
          "title": "Charge to be (at least partially) refunded"
        },
        "amount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "Amount to refund, must be less than or equal to this Charge's remaining,\nnon-refunded amount"
        },
        "reason": {
          "$ref": "#/definitions/v1RefundReason"
        },
        "clientRefundId": {
          "type": "string",
          "title": "Optional client-generated, unique ID\nSee Client IDs section above"
        }
      },
      "title": "Create Refund Request"
    },
    "v1CreateRefundResponse": {
      "type": "object",
      "title": "Create Refund Response"
    },
    "v1DeleteChargeResponse": {
      "type": "object",
      "title": "Delete Charge Response"
    },
    "v1GetAssetByCurrencyResponse": {
      "type": "object",
      "properties": {
        "assetId": {
          "type": "string"
        }
      },
      "title": "Get Asset By Currency Response"
    },
    "v1GetQuoteByAssetPairResponse": {
      "type": "object",
      "properties": {
        "quote": {
          "$ref": "#/definitions/v1Quote"
        }
      },
      "title": "Get Quote By Asset Pair Response"
    },
    "v1Quote": {
      "type": "object",
      "properties": {
        "quoteId": {
          "type": "string"
        },
        "assetPair": {
          "$ref": "#/definitions/typeAssetPair",
          "title": "Tuple of the base and quote assets"
        },
        "bidPrice": {
          "$ref": "#/definitions/typeDecimal",
          "title": "How many units of the quote asset would be paid to buy 1 unit of base asset"
        },
        "expireTime": {
          "type": "string",
          "format": "date-time",
          "title": "Time after which the quote is no longer valid"
        }
      }
    },
    "v1RefundReason": {
      "type": "string",
      "enum": [
        "REFUND_REASON_UNSPECIFIED",
        "REFUND_REASON_CUSTOMER_REQUESTED",
        "REFUND_REASON_MERCHANT_CANCELED"
      ],
      "default": "REFUND_REASON_UNSPECIFIED",
      "description": "- REFUND_REASON_UNSPECIFIED: Reserved as a default selection. Using this value not valid.",
      "title": "The cause of the refund request"
    },
    "v1WatchChargeResponse": {
      "type": "object",
      "properties": {
        "heartbeat": {
          "$ref": "#/definitions/v1WatchChargeResponseHeartbeat"
        },
        "created": {
          "$ref": "#/definitions/v1WatchChargeResponseCreated"
        },
        "deleted": {
          "$ref": "#/definitions/v1WatchChargeResponseDeleted"
        },
        "authorized": {
          "$ref": "#/definitions/v1WatchChargeResponseAuthorized"
        },
        "completed": {
          "$ref": "#/definitions/v1WatchChargeResponseCompleted"
        }
      },
      "title": "Watch Charge Response"
    },
    "v1WatchChargeResponseAuthorized": {
      "type": "object",
      "properties": {
        "amount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "Amount actually authorized (may be less than amount requested)"
        }
      },
      "description": "Authorized by payer (may still be deleted by either party)",
      "title": "Authorized"
    },
    "v1WatchChargeResponseCompleted": {
      "type": "object",
      "properties": {
        "amount": {
          "$ref": "#/definitions/typeAssetAmount",
          "title": "Amount actually paid (equal to amount authorized)"
        }
      },
      "description": "Paid/Completed",
      "title": "Completed"
    },
    "v1WatchChargeResponseCreated": {
      "type": "object",
      "description": "Newly created (pending)",
      "title": "Created"
    },
    "v1WatchChargeResponseDeleted": {
      "type": "object",
      "description": "Canceled by either party",
      "title": "Deleted"
    },
    "v1WatchChargeResponseHeartbeat": {
      "type": "object",
      "description": "See Streams section above",
      "title": "Heartbeat"
    },
    "v1WatchChargesResponse": {
      "type": "object",
      "properties": {
        "heartbeat": {
          "$ref": "#/definitions/v1WatchChargesResponseHeartbeat"
        },
        "event": {
          "$ref": "#/definitions/WatchChargesResponseEvent"
        }
      },
      "title": "Watch Charges Response"
    },
    "v1WatchChargesResponseHeartbeat": {
      "type": "object",
      "description": "See Streams section above",
      "title": "Heartbeat"
    }
  },
  "securityDefinitions": {
    "Bearer": {
      "type": "apiKey",
      "name": "Authorization",
      "in": "header"
    }
  },
  "security": [
    {
      "Bearer": []
    }
  ]
}
